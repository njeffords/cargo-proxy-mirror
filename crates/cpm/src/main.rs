//! Cargo proxy mirror command line tool
//!
//! Provides the ability to interact with the cache-mirror on protected network.

use std::{fs::File, io::{self, Read}, net::SocketAddr, path::PathBuf};

use structopt::StructOpt;
use displaydoc::Display;
use thiserror::Error;

use common::{
    cpm_api::{self,PackageId},
};

/// Manage acquiring missing crates from a disconnected network partition.
#[derive(StructOpt)]
struct Options {
    /// The end-point providing the caching service.
    ///
    /// Generally the registry override is pointing to.
    #[structopt(short, long, env = "CPM_API_SERVER_END_POINT")]
    server_end_point: SocketAddr,

    #[structopt(flatten)]
    command: Command
}

/// The possible sub-commands for this tool.
#[derive(StructOpt)]
enum Command {
    /// Record missing packages when comparing requirements from lock file with
    /// what's available in the cache.
    ///
    /// Produces a manifest that can be passed to the `dl-crates` tool on a
    /// machine with internet access to package the missing dependencies for
    /// transport across the network partition.
    Check{
        /// Lock file to check dependancy availability against
        #[structopt(parse(from_os_str), default_value = "Cargo.lock")]
        lock_file: PathBuf
    },

    /// Upload dependencies from an archive into the cache.
    ///
    /// Expects an archive generated by the `dl-crates` tool.
    Upload{
        #[structopt(parse(from_os_str))]
        tarball: PathBuf
    }
}

/// An error that can occur while exectuting a command.
#[derive(Error, Display, Debug)]
enum Error {
    /// An unexpected response was received from the mirror.
    UnexpectedResponse,

    /// IO error: {0}
    IoError(#[from] io::Error),

    /// Protocol error: {0}
    ProtocolError(#[from] cpm_api::Error),

    /// Protocol error: unexpected sequence recieved.
    SequenceError,

    /** A filename in the provided tar was not as expeceted. This
    probably means the tar file was not produced by the download tool.
    */
    BadTarFileName,
}

type Result<T> = std::result::Result<T,Error>;

/// Cargo.lock format
mod cargo_lock;

/// Interface to proxy-mirror service
mod cpm_api_client;

use cpm_api_client::CpmApiClient;

/// execute the `check` sub-command
fn check(server_end_point: SocketAddr, lock_file: PathBuf) -> Result<()> {

    eprintln!("checking lockfile: {:?}", lock_file);

    let lock_file = cargo_lock::load(lock_file)?;

    const SOURCE_CRATES_IO: &'static str = "registry+https://github.com/rust-lang/crates.io-index";

    let mut packages : Vec<PackageId> = Vec::new();

    for package in &lock_file.package {

        if package.checksum.is_none() {
            eprintln!("package wo/ checksum: {}", package.name);
        }

        if let Some(source) = &package.source {

            if source == SOURCE_CRATES_IO {
                packages.push(PackageId{
                    name:package.name.clone(),
                    version:package.version.clone()
                });
            } else {
                eprintln!("ignoring package with alternate source: {}", source)
            }

        } else {
            eprintln!("package wo/ source: {}", package.name);
        }
    }

    let mut client = CpmApiClient::new(server_end_point)?;

    let packages = client.check(packages)?;

    client.close()?;

    for package in packages {
        println!("{}/{}", package.name, package.version);
    }

    Ok(())
}

/// execute the `upload` sub-command
fn upload(server_end_point: SocketAddr, tarball: PathBuf) -> Result<()> {

    let tarball = File::open(tarball)?;

    let mut tarball = tar::Archive::new(tarball);

    let mut client = CpmApiClient::new(server_end_point)?;

    for entry in tarball.entries()? {
        let mut entry = entry?;

        let path = dbg!(entry.path()?).into_owned();

        let path : &str = path.to_str().ok_or(Error::BadTarFileName)?;

        let (name,version) = path.split_once('/').ok_or(Error::BadTarFileName)?;

        let size = entry.size() as usize;

        let mut file_bytes = Vec::new();

        file_bytes.resize(size, 0);

        entry.read_exact(&mut file_bytes)?;

        client.upload(name, version, file_bytes)?;
    }

    client.close()?;

    Ok(())
}

fn main() {
    use Command::*;
    let options = Options::from_args();
    match options.command {
        Check{lock_file} => if let Err(err) = check(options.server_end_point, lock_file) {
            eprintln!("error occured: {}", err);
        },
        Upload{tarball} => if let Err(err) = upload(options.server_end_point, tarball) {
            eprintln!("error occured: {}", err);
        }
    }
}
